.. raw:: latex

   \newpage

Задания
=======

.. include:: ./pytest.rst


Задание 26.1
~~~~~~~~~~~~

Изменить класс Topology из задания 25.1x.

Добавить метод, который позволит выполнять сложение двух объектов (экземпляров) Topology.
В результате сложения должен возвращаться новый экземпляр класса Topology.

Создание двух топологий:

.. code-block:: python

    In [1]: t1 = Topology(topology_example)

    In [2]: t1.topology
    Out[2]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

    In [3]: topology_example2 = {('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
                                 ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}

    In [4]: t2 = Topology(topology_example2)

    In [5]: t2.topology
    Out[5]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}

Суммирование топологий:

.. code-block:: python

    In [6]: t3 = t1+t2

    In [7]: t3.topology
    Out[7]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
     ('R1', 'Eth0/6'): ('R9', 'Eth0/0'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

Проверка, что исходные топологии не изменились

.. code-block:: python

    In [9]: t1.topology
    Out[9]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

    In [10]: t2.topology
    Out[10]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}


Задание 26.1a
~~~~~~~~~~~~~

В этом задании надо сделать так, чтобы экземпляры класса Topology были итерируемыми объектами.
Основу класса Topology можно взять из любого задания 25.1x или задания 26.1.

После создания экземпляра класса, экземпляр должен работать как итерируемый объект.
На каждой итерации должен возвращаться кортеж, который описывает одно соединение.
Порядок вывода соединений может быть любым.


Пример работы класса:

.. code-block:: python

    In [1]: top = Topology(topology_example)

    In [2]: for link in top:
       ...:     print(link)
       ...:
    (('R1', 'Eth0/0'), ('SW1', 'Eth0/1'))
    (('R2', 'Eth0/0'), ('SW1', 'Eth0/2'))
    (('R2', 'Eth0/1'), ('SW2', 'Eth0/11'))
    (('R3', 'Eth0/0'), ('SW1', 'Eth0/3'))
    (('R3', 'Eth0/1'), ('R4', 'Eth0/0'))
    (('R3', 'Eth0/2'), ('R5', 'Eth0/0'))


Проверить работу класса.

Задание 26.2
~~~~~~~~~~~~

Добавить к классу CiscoTelnet из задания 25.2x поддержку работы в менеджере контекста.
При выходе из блока менеджера контекста должно закрываться соединение.
Все исключения, которые возникли в менеджере контекста, должны генерироваться после выхода из блока with.

Пример работы:

.. code-block:: python

    In [14]: r1_params = {
        ...:     'ip': '192.168.100.1',
        ...:     'username': 'cisco',
        ...:     'password': 'cisco',
        ...:     'secret': 'cisco'}

    In [15]: from task_26_2 import CiscoTelnet

    In [16]: with CiscoTelnet(**r1_params) as r1:
        ...:     print(r1.send_show_command('sh clock'))
        ...:
    sh clock
    *19:17:20.244 UTC Sat Apr 6 2019
    R1#

    In [17]: with CiscoTelnet(**r1_params) as r1:
        ...:     print(r1.send_show_command('sh clock'))
        ...:     raise ValueError('Возникла ошибка')
        ...:
    sh clock
    *19:17:38.828 UTC Sat Apr 6 2019
    R1#
    ---------------------------------------------------------------------------
    ValueError                                Traceback (most recent call last)
    <ipython-input-17-f3141be7c129> in <module>
          1 with CiscoTelnet(**r1_params) as r1:
          2     print(r1.send_show_command('sh clock'))
    ----> 3     raise ValueError('Возникла ошибка')
          4

    ValueError: Возникла ошибка

Задание 26.3
~~~~~~~~~~~~


В этом задании необходимо создать класс IPAddress.

При создании экземпляра класса, как аргумент передается IP-адрес и маска,
а также выполняется проверка корректности адреса и маски:

* Адрес считается корректно заданным, если он:

  * состоит из 4 чисел разделенных точкой
  * каждое число в диапазоне от 0 до 255

* маска считается корректной, если это число в диапазоне от 8 до 32 включительно

Если маска или адрес не прошли проверку, необходимо сгенерировать исключение ValueError с соответствующим текстом (смотри вывод ниже).

Также, при создании класса, должны быть созданы два атрибута экземпляра: ip и mask, в которых содержатся адрес и маска, соответственно.

Пример создания экземпляра класса:

.. code-block:: python

    In [1]: ip = IPAddress('10.1.1.1/24')

    Атрибуты ip и mask
    In [2]: ip1 = IPAddress('10.1.1.1/24')

    In [3]: ip1.ip
    Out[3]: '10.1.1.1'

    In [4]: ip1.mask
    Out[4]: 24

    Проверка корректности адреса (traceback сокращен)
    In [5]: ip1 = IPAddress('10.1.1/24')
    ---------------------------------------------------------------------------
    ...
    ValueError: Incorrect IPv4 address

    Проверка корректности маски (traceback сокращен)
    In [6]: ip1 = IPAddress('10.1.1.1/240')
    ---------------------------------------------------------------------------
    ...
    ValueError: Incorrect mask


Задание 26.3a
~~~~~~~~~~~~~

Изменить класс IPAddress из задания 26.3.

Добавить два строковых представления для экземпляров класса IPAddress.
Как дожны выглядеть строковые представления, надо определить из вывода ниже:

Создание экземпляра

.. code-block:: python

    In [5]: ip1 = IPAddress('10.1.1.1/24')

    In [6]: str(ip1)
    Out[6]: 'IP address 10.1.1.1/24'

    In [7]: print(ip1)
    IP address 10.1.1.1/24

    In [8]: ip1
    Out[8]: IPAddress('10.1.1.1/24')

    In [9]: ip_list = []

    In [10]: ip_list.append(ip1)

    In [11]: ip_list
    Out[11]: [IPAddress('10.1.1.1/24')]

    In [12]: print(ip_list)
    [IPAddress('10.1.1.1/24')]

Для этого задания нет теста!
