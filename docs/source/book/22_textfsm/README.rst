Начало работы с TextFSM
=======================

Для начала библиотеку надо установить:

::

    pip install textfsm

Для использования TextFSM надо создать шаблон, по которому будет
обрабатываться вывод команды.

Пример вывода команды traceroute:

::

    r2#traceroute 90.0.0.9 source 33.0.0.2
    traceroute 90.0.0.9 source 33.0.0.2
    Type escape sequence to abort.
    Tracing the route to 90.0.0.9
    VRF info: (vrf in name/id, vrf out name/id)
      1 10.0.12.1 1 msec 0 msec 0 msec
      2 15.0.0.5  0 msec 5 msec 4 msec
      3 57.0.0.7  4 msec 1 msec 4 msec
      4 79.0.0.9  4 msec *  1 msec

Например, из вывода надо получить хопы, через которые прошел пакет.

В таком случае шаблон TextFSM будет выглядеть так (файл
traceroute.template):

::

    Value ID (\d+)
    Value Hop (\d+(\.\d+){3})

    Start
      ^  ${ID} ${Hop} -> Record

Первые две строки определяют переменные: 

* ``Value ID (\d+)`` - эта строка определяет переменную ID,
  которая описывает регулярное выражение: ``(\d+)`` - одна или более цифр,
  сюда попадут номера хопов 
* ``Value Hop (\d+(\.\d+){3})`` - эта строка определяет переменную Hop,
  которая описывает IP-адрес таким регулярным выражением: ``(\d+(\.\d+){3})``

После строки Start начинается сам шаблон. В данном случае он очень
простой: 

* ``^  ${ID} ${Hop} -> Record`` 
* сначала идет символ начала строки, затем два пробела и переменные ID и Hop 
* в TextFSM переменные описываются таким образом: ``${имя переменной}`` 
* слово ``Record`` в конце означает, что строки, которые попадут под описанный шаблон, будут
  обработаны и выведены в результаты TextFSM (с этим подробнее мы
  разберемся в следующем разделе

Скрипт для обработки вывода команды traceroute с помощью TextFSM
(parse_traceroute.py):

.. code:: python

    import textfsm

    traceroute = '''
    r2#traceroute 90.0.0.9 source 33.0.0.2
    traceroute 90.0.0.9 source 33.0.0.2
    Type escape sequence to abort.
    Tracing the route to 90.0.0.9
    VRF info: (vrf in name/id, vrf out name/id)
      1 10.0.12.1 1 msec 0 msec 0 msec
      2 15.0.0.5  0 msec 5 msec 4 msec
      3 57.0.0.7  4 msec 1 msec 4 msec
      4 79.0.0.9  4 msec *  1 msec
    '''

    with open('traceroute.template') as template:
        fsm = textfsm.TextFSM(template)
        result = fsm.ParseText(traceroute)

    print(fsm.header)
    print(result)

Результат выполнения скрипта:

::

    $ python parse_traceroute.py
    ['ID', 'Hop']
    [['1', '10.0.12.1'], ['2', '15.0.0.5'], ['3', '57.0.0.7'], ['4', '79.0.0.9']]

Строки, которые совпали с описанным шаблоном, возвращаются в виде списка
списков. Каждый элемент - это список, который состоит из двух элементов:
номера хопа и IP-адреса.

Разберемся с содержимым скрипта: 

* traceroute - это переменная, которая содержит вывод команды traceroute 
* ``template = open('traceroute.template')`` - содержимое файла с шаблоном
  TextFSM считывается в переменную template 
* ``fsm = textfsm.TextFSM(template)`` - класс, который обрабатывает шаблон
  и создает из него объект в TextFSM 
* ``result = fsm.ParseText(traceroute)`` - метод, который обрабатывает
  переданный вывод согласно шаблону и возвращает список списков, в котором
  каждый элемент - это обработанная строка 
* В конце выводится заголовок: ``print(fsm.header)``, 
  который содержит имена переменных и результат обработки

С этим выводом можно работать дальше. Например, периодически выполнять
команду traceroute и сравнивать, изменилось ли количество хопов и их
порядок.

Для работы с TextFSM нужны вывод команды и шаблон: 

* для разных команд нужны разные шаблоны 
* TextFSM возвращает результат обработки в табличном виде (в виде списка списков) 
* этот вывод легко преобразовать в csv формат или в список словарей

